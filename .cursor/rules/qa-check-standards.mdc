---
description: Standard QA check types and SQL templates
globs: ["**/*"]
alwaysApply: true
---

# QA Check Standards

When running QA checks on any table, ALWAYS run these standard checks.

---

## âš ï¸ CRITICAL: Environment Rules (READ FIRST)

**THIS IS MANDATORY. DO NOT SKIP THIS SECTION.**

| Check | Environment | Query PROD? | Notes |
|-------|-------------|-------------|-------|
| **1. Data Freshness** | ðŸŸ¢ **DEV ONLY** | âŒ NO | Query DEV dataset only |
| **2. Null Values** | ðŸŸ¢ **DEV ONLY** | âŒ NO | Query DEV dataset only |
| **3. Duplicates** | ðŸŸ¢ **DEV ONLY** | âŒ NO | Query DEV dataset only |
| **4. Ref. Integrity** | ðŸŸ¢ **DEV ONLY** | âŒ NO | Query DEV dataset only |
| **5. Invalid Values** | ðŸŸ¢ **DEV ONLY** | âŒ NO | Query DEV dataset only |
| **6. Distribution** | ðŸŸ¢ **DEV ONLY** | âŒ NO | Query DEV dataset only |
| **7. Logic Change** | ðŸ”µ **Git Diff** | âŒ NO | No SQL queries - analyze git diff only |
| **8. Data Impact** | ðŸŸ¡ **DEV vs PROD** | âœ… YES | Compare DEV to PROD baseline |

### Summary:
- **Checks 1-6:** Query **DEV_EDM_*** datasets ONLY. Never query PROD for these checks.
- **Check 7:** Analyze `git diff main` output. No BigQuery queries needed.
- **Check 8:** This is the ONLY check that queries both DEV and PROD to compare data impact.

### Why This Matters:
- DEV contains the candidate changes being tested
- PROD is the baseline for comparison (Check 8 only)
- Querying PROD for checks 1-6 is wasteful and confusing in QA reports

---

## 1. Data Freshness Check ðŸŸ¢ DEV ONLY
```sql
-- ENVIRONMENT: DEV ONLY - Do NOT query PROD
SELECT 
    'Data Freshness' as check_type,
    MAX({date_column}) as max_date,
    MIN({date_column}) as min_date,
    DATE_DIFF(CURRENT_DATE(), MAX({date_column}), DAY) as days_since_last_record
FROM `{project}.DEV_EDM_{layer}.{table_name}`
```

## 2. Null Value Check ðŸŸ¢ DEV ONLY
For each key column, check null percentages:
```sql
-- ENVIRONMENT: DEV ONLY - Do NOT query PROD
SELECT 
    COUNT(*) as total_rows,
    COUNTIF({column} IS NULL) as null_count,
    ROUND(COUNTIF({column} IS NULL) * 100.0 / COUNT(*), 2) as null_pct
FROM `{project}.DEV_EDM_{layer}.{table_name}`
```

## 3. Duplicate Check ðŸŸ¢ DEV ONLY
```sql
-- ENVIRONMENT: DEV ONLY - Do NOT query PROD
SELECT 
    COUNT(*) as total_rows,
    COUNT(DISTINCT {primary_key_columns}) as unique_rows,
    COUNT(*) - COUNT(DISTINCT {primary_key_columns}) as duplicate_count
FROM `{project}.DEV_EDM_{layer}.{table_name}`
```

## 4. Referential Integrity Check ðŸŸ¢ DEV ONLY
For each foreign key relationship:
```sql
-- ENVIRONMENT: DEV ONLY - Do NOT query PROD
SELECT 
    '{fact_table} -> {dim_table}' as relationship,
    '{fk_column}' as fk_column,
    COUNT(DISTINCT f.{fk_column}) as total_fk_values,
    COUNT(DISTINCT CASE WHEN d.{pk_column} IS NULL THEN f.{fk_column} END) as orphan_fk_values,
    ROUND(COUNT(DISTINCT CASE WHEN d.{pk_column} IS NULL THEN f.{fk_column} END) * 100.0 / 
          NULLIF(COUNT(DISTINCT f.{fk_column}), 0), 2) as orphan_pct
FROM `{project}.DEV_EDM_{layer}.{fact_table}` f
LEFT JOIN `{project}.DEV_EDM_{layer}.{dim_table}` d ON f.{fk_column} = d.{pk_column}
```

## 5. Invalid Values Check ðŸŸ¢ DEV ONLY
```sql
-- ENVIRONMENT: DEV ONLY - Do NOT query PROD
SELECT 
    COUNTIF({numeric_column} < 0) as negative_values,
    COUNTIF({numeric_column} = 0) as zero_values
FROM `{project}.DEV_EDM_{layer}.{table_name}`
```

## 6. Distribution Check ðŸŸ¢ DEV ONLY
For categorical columns:
```sql
-- ENVIRONMENT: DEV ONLY - Do NOT query PROD
SELECT 
    {categorical_column},
    COUNT(*) as row_count,
    ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER(), 2) as pct_of_total
FROM `{project}.DEV_EDM_{layer}.{table_name}`
GROUP BY 1
ORDER BY 2 DESC
```

## 7. Logic Change Check ðŸ”µ GIT DIFF ONLY (No SQL Queries)
For changed tables in a PR, analyze the git diff to determine if SQL logic was modified.
**No BigQuery queries needed for this check - analyze git diff output only.**

**Method:** Analyze `git diff main -- {file_path}`

| Change Type | Logic Changed? | Status |
|-------------|----------------|--------|
| Only comments (`--`, `/* */`) added/modified | âŒ No | âœ… |
| Only whitespace/formatting changes | âŒ No | âœ… |
| SQL statements modified (SELECT, FROM, WHERE, JOIN) | âœ… Yes | ðŸŸ¡ Review |
| CTE logic changed | âœ… Yes | ðŸŸ¡ Review |
| Column calculations/aggregations changed | âœ… Yes | ðŸŸ¡ Review |
| New columns added/removed | âœ… Yes | ðŸŸ¡ Review |
| Filter conditions changed | âœ… Yes | ðŸŸ¡ Review |
| dbt config changed (materialization, partitioning) | âœ… Yes | ðŸŸ¡ Review |

**How to check:**
```bash
git diff main -- {model_file_path} | grep -E "^[+-]" | grep -v "^[+-]{3}" | grep -v "^[+-]\s*--" | grep -v "^[+-]\s*/\*" | grep -v "^[+-]\s*\*"
```
- If output is empty (only comments/whitespace) â†’ Logic Changed = âŒ No
- If output has SQL changes â†’ Logic Changed = âœ… Yes

## 8. Data Impact Assessment Check ðŸŸ¡ DEV vs PROD COMPARISON

**This is the ONLY check that queries PROD.** Compare DEV (candidate) to PROD (baseline) to assess actual data impact.

For tables where logic has changed, run these SQL comparisons between DEV and PROD datasets:

### 8.1 Row Count Comparison (DEV vs PROD)
```sql
SELECT 
    'Row Count Comparison' as check_type,
    (SELECT COUNT(*) FROM `{project}.DEV_EDM_{layer}.{table_name}`) as dev_row_count,
    (SELECT COUNT(*) FROM `{project}.PROD_EDM_{layer}.{table_name}`) as prod_row_count,
    (SELECT COUNT(*) FROM `{project}.DEV_EDM_{layer}.{table_name}`) - 
    (SELECT COUNT(*) FROM `{project}.PROD_EDM_{layer}.{table_name}`) as row_difference,
    ROUND(
        ((SELECT COUNT(*) FROM `{project}.DEV_EDM_{layer}.{table_name}`) - 
         (SELECT COUNT(*) FROM `{project}.PROD_EDM_{layer}.{table_name}`)) * 100.0 / 
        NULLIF((SELECT COUNT(*) FROM `{project}.PROD_EDM_{layer}.{table_name}`), 0), 2
    ) as pct_change
```

**Thresholds:**
| Row Count Change | Impact Level | Status |
|------------------|--------------|--------|
| 0% change | None | âœ… |
| < 1% change | Low | ðŸŸ¡ |
| 1-5% change | Medium | ðŸŸ¡ |
| > 5% change | High | ðŸ”´ |

### 8.2 Value Changes Check (Key Metrics)
Compare aggregated values for key numeric columns:
```sql
SELECT 
    'Value Comparison' as check_type,
    '{metric_column}' as metric,
    (SELECT SUM({metric_column}) FROM `{project}.DEV_EDM_{layer}.{table_name}`) as dev_sum,
    (SELECT SUM({metric_column}) FROM `{project}.PROD_EDM_{layer}.{table_name}`) as prod_sum,
    ROUND(
        ((SELECT SUM({metric_column}) FROM `{project}.DEV_EDM_{layer}.{table_name}`) - 
         (SELECT SUM({metric_column}) FROM `{project}.PROD_EDM_{layer}.{table_name}`)) * 100.0 / 
        NULLIF((SELECT SUM({metric_column}) FROM `{project}.PROD_EDM_{layer}.{table_name}`), 0), 2
    ) as pct_change
```

**Thresholds:**
| Value Change | Impact Level | Status |
|--------------|--------------|--------|
| 0% change | None | âœ… |
| < 0.1% change | Low | ðŸŸ¡ |
| 0.1-1% change | Medium | ðŸŸ¡ |
| > 1% change | High | ðŸ”´ |

### 8.3 Schema Changes Check
Compare column structure between DEV and PROD:
```sql
-- Columns in DEV but not in PROD (new columns)
SELECT 
    'New Column (DEV only)' as change_type,
    column_name,
    data_type
FROM `{project}.DEV_EDM_{layer}.INFORMATION_SCHEMA.COLUMNS`
WHERE table_name = '{table_name}'
  AND column_name NOT IN (
    SELECT column_name 
    FROM `{project}.PROD_EDM_{layer}.INFORMATION_SCHEMA.COLUMNS`
    WHERE table_name = '{table_name}'
  )

UNION ALL

-- Columns in PROD but not in DEV (removed columns)
SELECT 
    'Removed Column (PROD only)' as change_type,
    column_name,
    data_type
FROM `{project}.PROD_EDM_{layer}.INFORMATION_SCHEMA.COLUMNS`
WHERE table_name = '{table_name}'
  AND column_name NOT IN (
    SELECT column_name 
    FROM `{project}.DEV_EDM_{layer}.INFORMATION_SCHEMA.COLUMNS`
    WHERE table_name = '{table_name}'
  )

UNION ALL

-- Data type changes
SELECT 
    'Data Type Changed' as change_type,
    d.column_name,
    CONCAT(p.data_type, ' -> ', d.data_type) as data_type
FROM `{project}.DEV_EDM_{layer}.INFORMATION_SCHEMA.COLUMNS` d
JOIN `{project}.PROD_EDM_{layer}.INFORMATION_SCHEMA.COLUMNS` p
  ON d.table_name = p.table_name AND d.column_name = p.column_name
WHERE d.table_name = '{table_name}'
  AND d.data_type != p.data_type
```

**Thresholds:**
| Schema Change | Impact Level | Status |
|---------------|--------------|--------|
| No changes | None | âœ… |
| New columns added | Low (additive) | ðŸŸ¡ |
| Data type changed | Medium | ðŸŸ¡ |
| Columns removed | High (breaking) | ðŸ”´ |

### 8.4 Downstream Breakage Check
Check if downstream tables reference columns being removed:
```sql
-- Find downstream tables that reference this table
-- (Check in qa_config.yml dependencies section)
-- Then verify all referenced columns still exist

SELECT 
    'Downstream Dependency' as check_type,
    '{downstream_table}' as dependent_table,
    '{referenced_column}' as referenced_column,
    CASE 
        WHEN '{referenced_column}' IN (
            SELECT column_name 
            FROM `{project}.DEV_EDM_{layer}.INFORMATION_SCHEMA.COLUMNS`
            WHERE table_name = '{table_name}'
        ) THEN 'EXISTS'
        ELSE 'MISSING - BREAKING CHANGE'
    END as status
```

### 8.5 Data Impact Summary

After running all checks above, summarize findings:

| Check | DEV | PROD | Change | Impact |
|-------|-----|------|--------|--------|
| Row Count | X | Y | Z% | âœ…/ðŸŸ¡/ðŸ”´ |
| {metric_1} Sum | X | Y | Z% | âœ…/ðŸŸ¡/ðŸ”´ |
| {metric_2} Sum | X | Y | Z% | âœ…/ðŸŸ¡/ðŸ”´ |
| Schema Changes | - | - | {count} changes | âœ…/ðŸŸ¡/ðŸ”´ |
| Downstream | - | - | {status} | âœ…/ðŸ”´ |
| **Overall Impact** | - | - | - | **{level}** |

**Overall Impact Level Calculation:**
- âœ… **None**: All checks pass, no changes detected
- ðŸŸ¡ **Low**: Only additive changes (new columns, <1% row/value change)
- ðŸŸ¡ **Medium**: Moderate changes (1-5% row/value change, data type changes)
- ðŸ”´ **High**: Breaking changes (columns removed, >5% change, downstream breakage)

## How to Run QA

**Default Behavior:** Always run QA checks on **changed tables only** (based on git diff or user context), unless user explicitly requests specific tables or all tables.

When user asks for QA on a table:
1. Identify the table and its dataset
2. Determine if table is **NEW** or **EXISTING** (check if PROD version exists)
3. Run appropriate checks based on table type

### âš ï¸ ENVIRONMENT REMINDER (Re-read if unsure)
| Checks 1-6 | Check 7 | Check 8 |
|------------|---------|---------|
| ðŸŸ¢ **DEV ONLY** | ðŸ”µ **Git Diff** | ðŸŸ¡ **DEV vs PROD** |
| Never query PROD | No SQL queries | Only check that queries PROD |

### For NEW Tables (no PROD version exists)
Run checks **1-6 only**:
- âœ… 1. Data Freshness Check
- âœ… 2. Null Value Check
- âœ… 3. Duplicate Check
- âœ… 4. Referential Integrity Check
- âœ… 5. Invalid Values Check
- âœ… 6. Distribution Check
- âšª 7. Logic Change Check â†’ **N/A** (no baseline to compare)
- âšª 8. Data Impact Assessment â†’ **N/A** (no PROD to compare)

### For EXISTING Tables (PROD version exists)
Run **ALL 8 checks**:
- âœ… 1-6: All data quality checks
- âœ… 7. Logic Change Check (compare git diff)
- âœ… 8. Data Impact Assessment (compare DEV vs PROD)

### How to Detect New vs Existing Table
```sql
-- Check if table exists in PROD
SELECT COUNT(*) as exists_in_prod
FROM `{project}.PROD_EDM_{layer}.INFORMATION_SCHEMA.TABLES`
WHERE table_name = '{table_name}'
```
- If `exists_in_prod = 0` â†’ NEW table
- If `exists_in_prod > 0` â†’ EXISTING table

4. Present results in standard output format as per qa-output-format rule
5. Flag any issues above thresholds
6. Provide actionable recommendations
